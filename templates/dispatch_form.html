<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dispatch Optimizer</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    label { display: block; margin-top: 10px; }
    input, button, select { padding: 5px; margin-top: 5px; }
    .route-block { border: 1px solid #aaa; padding: 16px; margin-bottom: 24px; background: #f9f9f9; border-radius: 7px; }
    .route-block h3 { margin: 0 0 10px 0; }
    .load-row { margin-bottom: 10px; display: flex; align-items: center; }
    .load-row input { margin-right: 0; border: 1px solid #ccc; box-sizing: border-box; }
    .load-header { display: flex; font-weight: bold; margin-bottom: 3px; }
    .load-header span,
    .load-row input { min-width: 130px; max-width: 130px; width: 130px; margin-right: 0; text-align: left; }
    .load-header span:last-child { min-width: 36px; max-width: 36px; width: 36px; }
    .load-row button { margin-left: 5px; min-width: 32px; }
    #spinner { display: none; margin: 30px auto; text-align: center; }
    #spinner svg { animation: spin 1s linear infinite; }
    @keyframes spin { 100% { transform: rotate(360deg); } }
    #addRouteBtn { display: inline-block; margin-bottom: 10px; }
    .remove-route-btn { float: right; color: #e53e3e; display: inline; }
    .sort-toggle { margin-bottom: 10px; font-size: 16px; }
    .results-table { border-collapse: collapse; width: 100%; margin: 18px 0; background: #fff; }
    .results-table th, .results-table td { border: 1px solid #bbb; padding: 6px 10px; text-align: center; }
    .results-table th { background: #f4f4f4; }
    .settings-block { margin: 18px 0; }
    .settings-block label { margin-right: 12px; display: inline-block; }
    .settings-block input { margin-right: 18px; width: 60px; }
  </style>
  <!-- Dynamically loaded Google Maps API in JS below -->
</head>
<body>
  <h2>Dispatch Optimizer</h2>
  <form id="dispatchForm">
    <label for="routeMode">Route Type:</label>
    <select id="routeMode" name="routeMode">
      <option value="best">Best Route (AI Optimized)</option>
      <option value="manual">Best Route (Manual)</option>
      <option value="direct" selected>Direct Route (Loads in Order, Multi-Route)</option>
    </select>
    <div class="settings-block" id="extraSettings" style="display:none;">
      <label>
        Loaded % Goal:
        <input type="number" id="loadedPctGoal" value="65" min="1" max="100" step="1" />
      </label>
      <label>
        Max Chain Length:
        <input type="number" id="maxChainLength" value="6" min="1" max="20" step="1" />
      </label>
    </div>
    <div id="routesContainer"></div>
    <button type="button" id="addRouteBtn" onclick="addRouteBlock()">‚ûï Add Route</button><br><br>
    <button type="submit">Submit</button>
    <button id="cancelButton" onclick="cancelTask()" style="display:none;">Cancel</button>
  </form>

  <!-- Sorting toggle for manual mode -->
  <div id="sortToggleDiv" class="sort-toggle" style="display:none;">
    <label>Sort By:
      <select id="sortToggle">
        <option value="loaded_pct">Loaded % (High to Low)</option>
        <option value="rpm">RPM ($/mile, High to Low)</option>
      </select>
    </label>
  </div>

  <!-- Excel Import -->
  <div style="margin: 10px 0;">
    <label for="excelInput" style="cursor:pointer;">
      üì• <strong>Import from Excel</strong>
    </label>
    <input type="file" id="excelInput" accept=".xlsx" style="display:none;" />
  </div>

<div id="spinner" style="display:none; text-align:center; margin-top:20px;">
  <!-- Progress Bar -->
  <div style="width: 100%; max-width: 400px; margin: 0 auto 16px auto; background: #eee; border-radius: 8px; overflow: hidden;">
    <div id="progressBarFill" style="width: 0%; height: 12px; background: #319795; transition: width 0.3s;"></div>
  </div>

  <!-- Spinner Icon -->
  <svg width="50" height="50" viewBox="0 0 50 50">
    <circle
      cx="25" cy="25" r="20"
      stroke="#319795" stroke-width="5"
      fill="none"
      stroke-linecap="round"
      stroke-dasharray="90"
      stroke-dashoffset="60">
      <animateTransform
        attributeName="transform"
        type="rotate"
        from="0 25 25"
        to="360 25 25"
        dur="1s"
        repeatCount="indefinite"/>
    </circle>
  </svg>

  <!-- Text -->
  <div style="color:#319795; margin-top: 10px;">
    Calculating optimal routes... <span id="progressText">0%</span>
  </div>
</div>

  <div id="output" style="margin-top:30px;"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script>
document.getElementById("excelInput").addEventListener("change", async (e) => {
  if (currentRouteMode === "direct") {
    alert("Excel import is only available in AI or Best Route mode.");
    return;
  }

  const file = e.target.files[0];
  if (!file) return;

  const data = await file.arrayBuffer();
  const workbook = XLSX.read(data);
  const sheetName = workbook.SheetNames[0];
  const rows = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName]);

  const formattedLoads = rows.map(r => {
    const pickup = (r["Shipper City"] || "").toString().replace(/\/$/, "").trim();
    const dropoff = (r["Consignee City"] || "").toString().replace(/\/$/, "").trim();
    const weight = parseFloat(r["Weight"]) || 43;
    return { pickupCity: pickup, dropoffCity: dropoff, weight, rate: 0 };
  }).filter(r => r.pickupCity && r.dropoffCity);

  // Remove duplicates by pickup+dropoff+weight
  const uniqueLoads = Array.from(
    new Map(formattedLoads.map(load => [load.pickupCity + load.dropoffCity + load.weight, load])).values()
  );

  const routeDiv = document.querySelector(".route-block");
  const loadsContainer = routeDiv.querySelector('.loadsContainer');
  loadsContainer.innerHTML = "";
  uniqueLoads.forEach(load => {
    addLoadRowWithValues(loadsContainer, {
      pickup: load.pickupCity,
      dropoff: load.dropoffCity,
      weight: load.weight,
      rate: 0,
      count: "1",
      required: false
    });
  });

  renderLoadHeaderAndRows(routeDiv);
  alert(`Imported ${uniqueLoads.length} loads.`);
});
</script>

<script>
const GOOGLE_API_KEY = "{{ google_api_key }}";
let googleMapsLoaded = false;
function loadGoogleMapsApi(callback) {
  if (window.google && window.google.maps) {
    callback();
    return;
  }
  if (document.getElementById('googleMapsScript')) {
    document.getElementById('googleMapsScript').addEventListener('load', callback);
    return;
  }
  const script = document.createElement('script');
  script.id = 'googleMapsScript';
  script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_API_KEY}&callback=onGoogleMapsLoaded`;
  script.async = true;
  script.defer = true;
  window.onGoogleMapsLoaded = function () {
    googleMapsLoaded = true;
    callback();
  };
  document.head.appendChild(script);
}

function startAsyncDispatch(payload) {
  fetch("/dispatch_async", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  })
    .then(res => res.json())
    .then(data => {
      const taskId = data.task_id;
      document.getElementById("cancelButton").style.display = "inline";
      document.querySelector("button[type='submit']").style.display = "none";
      pollTaskProgress(taskId);
    });
}

let routeCount = 0;
let currentRouteMode = "direct";
let resultsCache = [];
let currentTaskId = null;

async function startDispatch() {
  // after getting task_id:
  currentTaskId = data.task_id;
  document.getElementById("cancelButton").style.display = "inline";
}

async function cancelTask() {
  if (!currentTaskId) return;
  await fetch(`/cancel_task/${currentTaskId}`, { method: "POST" });
  document.getElementById("output").innerHTML = "<div style='color:red;'>Task cancelled.</div>";
  document.getElementById("spinner").style.display = "none";
  document.getElementById("cancelButton").style.display = "none";
  document.querySelector("button[type='submit']").style.display = "inline";
}

function addRouteBlock() {
  routeCount += 1;
  const routesContainer = document.getElementById('routesContainer');
  const routeDiv = document.createElement('div');
  routeDiv.className = "route-block";
  routeDiv.dataset.routeIndex = routeCount;
  routeDiv.innerHTML = `
    <h3>
      Route ${routeCount}
      <button type="button" class="remove-route-btn" onclick="removeRouteBlock(this)">Remove Route</button>
      <button type="button" onclick="saveThisRoute(this)" style="float:right;margin-left:8px;">üíæ Save</button>
      <select class="trip-select" onchange="handleTripSelect(this)" style="float:right; margin-left: 8px;"></select>
      <button type="button" onclick="clearSelectedTrip(this)" style="float:right;">Clear</button>
      <button type="button" onclick="deleteSelectedTrip(this)" style="float:right; margin-left: 8px; color:#e53e3e;">‚ùå</button>

      <!-- Excel Import -->
      <div id="excelImportSection" style="margin: 10px 0; style="display:none;"">
        <label for="excelInput" style="cursor:pointer;">
          üì• <strong>Import from Excel</strong>
        </label>
        <input type="file" id="excelInput" accept=".xlsx" style="display:none;" />
      </div>

    </h3>
    <label>Start Location:</label>
    <input type="text" name="start" placeholder="Starting Point" required />
    <label>End Location:</label>
    <input type="text" name="end" placeholder="Ending Point" required />
    <div class="load-header"></div>
    <div class="loadsContainer"></div>
    <button type="button" onclick="addLoadRow(this)">‚ûï Add Load</button>
  `;
  populateTripDropdown(routeDiv);
  routesContainer.appendChild(routeDiv);
  renderLoadHeaderAndRows(routeDiv, true);
  updateRouteUI();
}

function removeRouteBlock(btn) {
  btn.closest('.route-block').remove();
  updateRouteNumbers();
  updateRouteUI();
}

function addLoadRow(routeBtn) {
  const routeDiv = routeBtn.closest('.route-block');
  const loadsContainer = routeDiv.querySelector('.loadsContainer');
  addLoadRowWithValues(loadsContainer, {
    pickup: "",
    dropoff: "",
    rate: "0",
    weight: "43",
    required: false,
    count: "1"
  });
}

function addLoadRowWithValues(loadsContainer, values) {
  const mode = currentRouteMode;
  const row = document.createElement('div');
  row.className = "load-row";
  row.innerHTML = `
    <input type="text" name="pickup" placeholder="Pickup City" required value="${values.pickup || ""}" />
    <input type="text" name="dropoff" placeholder="Dropoff City" required value="${values.dropoff || ""}" />
    ${mode === "best" ? `<input type="number" name="count" placeholder="# of Loads" value="${values.count || 1}" min="1" required />` : ""}
    <input type="number" name="rate" placeholder="Rate" value="${values.rate || 0}" min="0" step="0.01" required />
    <input type="number" name="weight" placeholder="Weight" min="0" step="0.01" value="${values.weight || 43}" required />
    ${mode === "manual" ? `<input type="checkbox" name="required" style="margin-left:6px;" />` : ""}
    <button type="button" onclick="removeLoadRow(this)">‚ùå</button>
  `;
  loadsContainer.appendChild(row);
}

function removeLoadRow(btn) {
  btn.parentElement.remove();
}

function updateRouteNumbers() {
  const blocks = document.querySelectorAll('.route-block');
  blocks.forEach((block, i) => {
    const h3 = block.querySelector('h3');
    h3.innerHTML = `Route ${i + 1} <button type="button" class="remove-route-btn" onclick="removeRouteBlock(this)">Remove Route</button>`;
    block.dataset.routeIndex = i + 1;
  });
  routeCount = blocks.length;
}

function renderLoadHeaderAndRows(routeDiv, clearRequired = false) {
  const header = routeDiv.querySelector('.load-header');
  if (!header) return;
  let headerHtml = `
    <span>Pickup</span>
    <span>Dropoff</span>
    ${currentRouteMode === "best" ? "<span># of Loads</span>" : ""}
    <span>Rate ($/MT)</span>
    <span>Weight (MT)</span>
    ${currentRouteMode === "manual" ? "<span>Required?</span>" : ""}
    <span></span>
  `;
  header.innerHTML = headerHtml;
  const loadsContainer = routeDiv.querySelector('.loadsContainer');
  const rows = Array.from(loadsContainer.querySelectorAll('.load-row'));
  const oldVals = rows.map(row => ({
    pickup: row.querySelector("input[name='pickup']").value,
    dropoff: row.querySelector("input[name='dropoff']").value,
    rate: row.querySelector("input[name='rate']").value,
    weight: row.querySelector("input[name='weight']").value,
    required: false,
    count: row.querySelector("input[name='count']") ? row.querySelector("input[name='count']").value : "1"
  }));
  loadsContainer.innerHTML = "";
  oldVals.forEach(vals => addLoadRowWithValues(loadsContainer, vals));
  if (oldVals.length === 0) addLoadRowWithValues(loadsContainer, {});
}

function updateRouteUI() {
  const addRouteBtn = document.getElementById("addRouteBtn");
  const routesContainer = document.getElementById("routesContainer");
  const blocks = document.querySelectorAll('.route-block');
  blocks.forEach(block => renderLoadHeaderAndRows(block, true));
  blocks.forEach(block => {
    const startInput = block.querySelector("input[name='start']");
    const endInput = block.querySelector("input[name='end']");
    if (currentRouteMode === "direct") {
      startInput.removeAttribute("required");
      endInput.removeAttribute("required");
    } else {
      startInput.setAttribute("required", "required");
      endInput.setAttribute("required", "required");
    }
  });
  if (currentRouteMode === "direct") {
    addRouteBtn.style.display = "inline-block";
    const removeBtns = document.querySelectorAll('.remove-route-btn');
    removeBtns.forEach(btn => btn.style.display = (routeCount > 1 ? "inline" : "none"));
  } else {
    addRouteBtn.style.display = "none";
    while (routesContainer.children.length > 1) {
      routesContainer.removeChild(routesContainer.lastChild);
    }
    routeCount = 1;
    updateRouteNumbers();
    const removeBtns = document.querySelectorAll('.remove-route-btn');
    removeBtns.forEach(btn => btn.style.display = "none");
  }
  document.getElementById("extraSettings").style.display = (currentRouteMode === "manual" || currentRouteMode === "best") ? "block" : "none";
  document.getElementById("sortToggleDiv").style.display = (currentRouteMode === "manual") ? "block" : "none";
  document.getElementById("excelImportSection").style.display = (currentRouteMode === "direct") ? "block" : "none";
}

// --- SUBMIT HANDLER ---
document.getElementById("dispatchForm").addEventListener("submit", async function (e) {
  e.preventDefault();
  document.getElementById("output").innerHTML = "";
  document.getElementById("spinner").style.display = "block";
  resultsCache = [];
  // Collect route blocks
  const routeBlocks = document.querySelectorAll('.route-block');
  let dataToSend = [];
  for (const routeDiv of routeBlocks) {
    const pickups = routeDiv.querySelectorAll("input[name='pickup']");
    const dropoffs = routeDiv.querySelectorAll("input[name='dropoff']");
    let start = routeDiv.querySelector("input[name='start']").value.trim();
    let end = routeDiv.querySelector("input[name='end']").value.trim();
    const counts = routeDiv.querySelectorAll("input[name='count']");
    const rates = routeDiv.querySelectorAll("input[name='rate']");
    const weights = routeDiv.querySelectorAll("input[name='weight']");
    const requireds = routeDiv.querySelectorAll("input[name='required']");
    const isManualMode = (currentRouteMode === "manual");
    const isBestMode = (currentRouteMode === "best");
    const loads = [];
    for (let i = 0; i < pickups.length; i++) {
      const pickup = pickups[i].value.trim();
      const dropoff = dropoffs[i].value.trim();
      const count = isBestMode ? parseInt(counts[i].value) : 1;
      const rate = parseFloat(rates[i].value);
      const weight = parseFloat(weights[i].value);
      const required = isManualMode && requireds[i] ? requireds[i].checked : false;
      for (let j = 0; j < count; j++) {
        loads.push({ pickupCity: pickup, dropoffCity: dropoff, rate, weight, required });
      }
    }
    if (currentRouteMode === "direct") {
      if (!start && loads.length) {
        start = loads[0].pickupCity || "";
      }
      if (!end && loads.length) {
        end = loads[loads.length - 1].dropoffCity || "";
      }
    }
    dataToSend.push({ start, end, loads });
  }

  // Get extra settings if relevant
  let loadedPctGoal = Number(document.getElementById("loadedPctGoal")?.value || 65);
  let maxChainLength = Number(document.getElementById("maxChainLength")?.value || 6);

  try {
  let endpoint, payload;
  if (currentRouteMode === "manual") {
    // Use async version
    endpoint = "/dispatch_async";
    payload = { ...dataToSend[0], loaded_pct_goal: loadedPctGoal, max_chain_amount: maxChainLength };

    // Show spinner + launch async task
    document.getElementById("spinner").style.display = "block";
    const res = await fetch(endpoint, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    const { task_id } = await res.json();
    document.getElementById("cancelButton").style.display = "inline";
    document.querySelector("button[type='submit']").style.display = "none";
    pollTaskProgress(task_id); // defined below
    return; // Exit early ‚Äî everything else is handled via polling
  }

  if (currentRouteMode === "direct") {
    endpoint = "/direct_route_multi";
    payload = { routes: dataToSend };
  } else {
    endpoint = "/dispatch";
    payload = { ...dataToSend[0], loaded_pct_goal: loadedPctGoal, max_chain_amount: maxChainLength };
  }

  const response = await fetch(endpoint, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload)
  });

  if (currentRouteMode === "direct") {
    const data = await response.json();
    if (data.error) throw new Error(data.error);
    resultsCache = Array.isArray(data) ? data : data.routes;
    renderResultsTable(resultsCache);
  } else {
    const html = await response.text();
    document.getElementById("output").innerHTML = html;
  }
} catch (err) {
  document.getElementById("output").innerHTML = "<div style='color:red;'>Error. Please try again.<br>" + (err.message || err) + "</div>";
} finally {
  if (currentRouteMode !== "manual") {
    document.getElementById("spinner").style.display = "none";
    document.querySelector("button[type='submit']").style.display = "inline";
    document.getElementById("cancelButton").style.display = "none";
  }
}
});


// ‚¨áÔ∏è Keep this outside the submit handler!
function pollTaskProgress(taskId) {
  const spinner = document.getElementById("spinner");
  document.getElementById("progressText").innerText = "0%";
  document.getElementById("progressBarFill").style.width = "0%";

  const interval = setInterval(async () => {
    const res = await fetch(`/task_status/${taskId}`);
    const data = await res.json();

    if (data.progress !== undefined) {
      document.getElementById("progressText").innerText = `${data.progress}%`;
      document.getElementById("progressBarFill").style.width = `${data.progress}%`;
    }

    if (data.state === "complete") {
      clearInterval(interval);
      spinner.style.display = "none";
      document.querySelector("button[type='submit']").style.display = "inline-block";
      document.getElementById("cancelButton").style.display = "none";
      resultsCache = Array.isArray(data.result) ? data.result : [];
      renderResultsTable(resultsCache);
    }

    if (data.state === "error") {
      clearInterval(interval);
      document.getElementById("output").innerHTML = `<span style="color:red;">‚ùå Error: ${data.error}</span>`;
      spinner.style.display = "none";
      document.querySelector("button[type='submit']").style.display = "inline-block";
      document.getElementById("cancelButton").style.display = "none";
    }
  }, 1000);
}

document.getElementById("sortToggle").addEventListener("change", function () {
  if (resultsCache.length) renderResultsTable(resultsCache);
});

function getOrderedCitiesFromSteps(steps) {
  let cities = [];
  steps.forEach(s => {
    let seg = s.segment.replace(/<[^>]+>/g, '');
    let parts = seg.split('‚Üí').map(x => x.trim());
    parts.forEach(p => {
      // Always include last city even if same as first
      if (!cities.length || p !== cities[cities.length-1] || p === parts[parts.length-1]) {
        cities.push(p);
      }
    });
  });
  // Ensure last city from last segment is included
  if (cities[cities.length-1] !== steps[steps.length-1].segment.split('‚Üí').pop().trim()) {
    cities.push(steps[steps.length-1].segment.split('‚Üí').pop().trim());
  }
  return cities;
}

function populateTripDropdown(routeDiv) {
  const select = routeDiv.querySelector('.trip-select');
  const allSaves = JSON.parse(localStorage.getItem("savedTrips") || "{}");
  const options = Object.keys(allSaves).map(name => `<option value="${name}">${name}</option>`).join('');
  select.innerHTML = `<option value="">-- Select Saved Trip --</option>${options}`;
}

// Google Map Plotting
function plotGoogleRouteMap(steps, mapId) {
  let cities = getOrderedCitiesFromSteps(steps);
  if (cities.length < 2) return;
  loadGoogleMapsApi(() => {
    const map = new google.maps.Map(document.getElementById(mapId), {
      zoom: 6,
      center: { lat: 50, lng: -99 }
    });
    const directionsService = new google.maps.DirectionsService();
    const directionsRenderer = new google.maps.DirectionsRenderer({ map });
    const [origin, ...rest] = cities;
    const destination = rest.pop();
    const waypoints = rest.map(city => ({ location: city, stopover: true }));
    directionsService.route({
      origin: origin,
      destination: destination,
      waypoints: waypoints,
      travelMode: google.maps.TravelMode.DRIVING
    }, (result, status) => {
      if (status === "OK") {
        directionsRenderer.setDirections(result);
      } else {
        // fallback: just drop pins
        cities.forEach(city => {
          new google.maps.Geocoder().geocode({ address: city }, (res, stat) => {
            if (stat === 'OK' && res[0]) {
              new google.maps.Marker({ map, position: res[0].geometry.location, title: city });
            }
          });
        });
      }
    });
  });
}

function renderResultsTable(routes) {
  if (!routes.length) {
    document.getElementById("output").innerHTML = "<div style='color:#e53e3e'>No routes found with 65%+ loaded km.</div>";
    return;
  }
  let sortBy = document.getElementById("sortToggle").value;
  let sorted = [...routes].sort((a, b) => {
    let aMetric = a.summary ? a.summary[sortBy] : a[sortBy];
    let bMetric = b.summary ? b.summary[sortBy] : b[sortBy];
    return bMetric - aMetric;
  });
  let ths = `<tr>
    <th>City Sequence</th>
    <th>Load IDs</th>
    <th>Loaded km</th>
    <th>Empty km</th>
    <th>Loaded %</th>
    <th>Total km</th>
    <th>Revenue</th>
    <th>RPM ($/mile)</th>
    <th>Details</th>
  </tr>`;
  let trs = sorted.map((r, i) => {
    let summary = r.summary || r;
    let citySeq = r.city_sequence || (summary.start + " ‚Üí ... ‚Üí " + summary.end);
    let loadIds = (r.load_ids && r.load_ids.length) ? r.load_ids.join(", ") : (summary.load_ids ? summary.load_ids.join(", ") : "-");
    let expandedId = `expando${i}`;
    return `<tr>
      <td>${citySeq}</td>
      <td>${loadIds}</td>
      <td>${summary.loaded_km}</td>
      <td>${summary.empty_km}</td>
      <td>${summary.loaded_pct}%</td>
      <td>${summary.total_km}</td>
      <td>${summary.total_revenue !== undefined ? summary.total_revenue : summary.revenue}</td>
      <td>${summary.rpm}</td>
      <td><button onclick="toggleDetails('${expandedId}')">Expand</button></td>
    </tr>
    <tr id="${expandedId}" style="display:none;background:#f6faff"><td colspan="9">${renderBreakdownTable(r.step_breakdown, i)}</td></tr>`;
  }).join("");
  document.getElementById("output").innerHTML = `<table class="results-table">${ths}${trs}</table>`;
}

function renderBreakdownTable(steps, routeIdx = 0) {
  if (!steps || !steps.length) return "<div>No breakdown available.</div>";
  let th = `<tr>
    <th>Step Type</th>
    <th>Segment</th>
    <th>KMs</th>
    <th>Rate</th>
    <th>Weight</th>
    <th>Revenue</th>
    <th>RPM ($/mile)</th>
  </tr>`;
  let rows = steps.map(s =>
    `<tr>
      <td>${capitalize(s.type)}</td>
      <td>${s.segment}</td>
      <td>${s.kms}</td>
      <td>${s.rate}</td>
      <td>${s.weight}</td>
      <td>${s.revenue}</td>
      <td>${s.rpm}</td>
    </tr>`
  ).join("");
  // --- Add map container (unique per details section)
  const mapId = `routeMap${routeIdx}`;
  setTimeout(() => plotGoogleRouteMap(steps, mapId), 0);
  return `
    <table class="results-table" style="margin:8px 0">${th}${rows}</table>
    <div style="height:320px;margin:10px 0;border-radius:12px;overflow:hidden;">
      <div id="${mapId}" style="width:100%;height:100%;"></div>
    </div>
  `;
}

function capitalize(str) {
  return str ? str.charAt(0).toUpperCase() + str.slice(1) : "";
}

window.toggleDetails = function (id) {
  const row = document.getElementById(id);
  if (!row) return;
  row.style.display = (row.style.display === "none") ? "" : "none";
};

function clearSelectedTrip(btn) {
  const routeDiv = btn.closest('.route-block');
  const select = routeDiv.querySelector(".trip-select");

  // Clear input fields
  routeDiv.querySelector("input[name='start']").value = "";
  routeDiv.querySelector("input[name='end']").value = "";

  // Clear all loads
  const loadsContainer = routeDiv.querySelector('.loadsContainer');
  loadsContainer.innerHTML = "";
  addLoadRowWithValues(loadsContainer, {}); // Add one empty row

  // Clear dropdown selection
  if (select) select.value = "";

  renderLoadHeaderAndRows(routeDiv);
}


function deleteSelectedTrip(btn) {
  const routeDiv = btn.closest('.route-block');
  const select = routeDiv.querySelector(".trip-select");
  const name = select?.value;
  if (!name) return;
  if (!confirm(`Delete saved trip "${name}"?`)) return;
  const allSaves = JSON.parse(localStorage.getItem("savedTrips") || "{}");
  delete allSaves[name];
  localStorage.setItem("savedTrips", JSON.stringify(allSaves));
  populateTripDropdown(routeDiv);
  clearSelectedTrip(btn);
  alert(`Trip "${name}" deleted.`);
}

function saveThisRoute(btn) {
  const routeDiv = btn.closest('.route-block');
  const select = routeDiv.querySelector(".trip-select");
  let defaultName = select?.value || "";
  let name = prompt("Enter a name for this trip:", defaultName);
  if (!name) return;

  const allSaves = JSON.parse(localStorage.getItem("savedTrips") || "{}");
  if (allSaves[name] && name !== defaultName) {
    const confirmOverwrite = confirm(`A trip named "${name}" already exists. Overwrite it?`);
    if (!confirmOverwrite) return;
  }

  const start = routeDiv.querySelector("input[name='start']").value.trim();
  const end = routeDiv.querySelector("input[name='end']").value.trim();
  const loads = Array.from(routeDiv.querySelectorAll(".load-row")).map(row => ({
    pickup: row.querySelector("input[name='pickup']").value,
    dropoff: row.querySelector("input[name='dropoff']").value,
    rate: row.querySelector("input[name='rate']").value,
    weight: row.querySelector("input[name='weight']").value,
    count: row.querySelector("input[name='count']")?.value || "1",
    required: row.querySelector("input[name='required']")?.checked || false
  }));
  const saveObj = { start, end, loads };
  allSaves[name] = saveObj;
  localStorage.setItem("savedTrips", JSON.stringify(allSaves));
  populateTripDropdown(routeDiv);
  select.value = name;
  alert(`Trip "${name}" saved!`);
}

function handleTripSelect(selectEl) {
  const name = selectEl.value;
  if (!name) return;
  const routeDiv = selectEl.closest('.route-block');
  const saved = JSON.parse(localStorage.getItem("savedTrips") || "{}")[name];
  if (!saved) return;

  routeDiv.querySelector("input[name='start']").value = saved.start || "";
  routeDiv.querySelector("input[name='end']").value = saved.end || "";
  const loadsContainer = routeDiv.querySelector('.loadsContainer');
  loadsContainer.innerHTML = "";
  saved.loads.forEach(load => addLoadRowWithValues(loadsContainer, load));
  renderLoadHeaderAndRows(routeDiv);
}

window.onload = function () {
  addRouteBlock();
  document.getElementById("routeMode").value = "direct";
  updateRouteUI();
  document.getElementById('routeMode').addEventListener('change', function () {
    currentRouteMode = this.value;
    updateRouteUI();
    document.getElementById("output").innerHTML = "";
  });
};
</script>
</body>
</html>
